[{"title":"逆向入门","url":"/2024/07/07/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8/","content":"逆向简单入个门简单讲两句逆向工程入门这个东西（有什么讲不好的地方轻点喷）\n什么是逆向工程什么是逆向？ 通俗来讲就是，计算机科学中的逆向工程就是将机器才能够懂的机器代码（二进制代码）翻译成人能够读懂的代码（汇编代码，C语言代码），并在此基础上分析出程序的工作流程。\n举个栗子写一个简单的C语言程序\n#include &quot;windows.h&quot;#include &quot;tchar.h&quot;int _tmain(int argc, TCHAR* argv[])&#123;\tMessageBox(\t\tNULL,\t\tL&quot;Hello World&quot;,\t\tL&quot;just a reverse&quot;,\t\tMB_OK\t);\treturn 0;&#125;\n\n用gcc或者其他编译器或者IDE进行编译\ngcc helloworld.c -o helloworld.exe\n\ngcc这个编译器实际上是linux那边的开源编译器，然后的话我这边是用vs编译的（偷个懒\n这边把生成的程序根据对应的架构，放入到对应的调试器里面，我这边生成的是32位的，所以丢到ollydbg里面（简称OD）,64位的要丢到x64dbg里面\n前面OD反汇编了不少启动函数，这边先啥也不管，直接来到我们的主函数main()这边\n\n这个就是我们编译出来的代码的汇编语言\n虽然现在有ghira，ida这种高级反汇编工具能生成跟源代码相近的c语言伪代码，但是作为逆向工程的基础，汇编语言还是很重要的，所以还是得去阅读，尝试去分析和理解这种格式的汇编代码\n前置条件入门需要的科技树：\n​        1.C语言的代码审计能力（这个东西入门时期最重要的）\n​        2.汇编语言：通常是x86-64架构指令\n​        3.调试能力\nCTF-Re快速入门问就是刷题，狠狠的刷题，在各种的刷题平台上狠狠的刷题\n常见的平台有:BUUCTF在线评测 (buuoj.cn),攻防世界 (xctf.org.cn),nssctf（https://www.nssctf.cn/index）\n入门期间，如果可以的话，最好是每天一题的频率，每天在刷题的时候，也最好学习一些相应的知识\n要是碰到实在做不出来的，完全可以是去查找对应的writeup（简称wp）,俗称就是看前人的写题过程，当然最好是找那些详细的，有些人写wp很简略的。\n在刷到一定程度之后，可以适当的去打打一些线上的新生赛这种，在不会太难的程度上，同时学习一些新东西。\n推荐书籍这种东西其实入门的时候不怎么需要，当然日后要是深入的话，书籍可太需要了\n我这边就讲讲我个人比较喜欢的书\n1.逆向工程核心原理：这本书是windows环境下的逆向书籍，里面内容挺详细的\n2.C++反汇编与逆向分析技术揭秘：非常好的小黄书，使我的逆向旋转，挺经典的一本，可以看看\n3.C Primer Plus: 学C语言用的，但是找一些比较偏的语法是找不到的\n4.汇编语言 基于x86处理器：挺详细一本汇编语言书，我学汇编就看的这本\n5.深入理解计算机系统：四舍五入这也是本前置条件，是我想买但没买的书（\n6.Linux二进制分析：linux环境的话可以看看这本\n7.程序员的自我修养——链接、装载与库：介绍了 C 源代码如何经过一系列的操作最终变为二进制程序\n8.加密与解密：看雪论坛最新力作（就是有点贵），里面讲的挺多关于逆向保护和破解方面的东西\n9.IDA权威指南：这位更是IDA作者鼎力推荐，教会你如何快乐地使用IDA\n推荐资源教程类​    1.简介 - CTF Wiki (ctf-wiki.org) : wiki里面有比较详细的解读\n​    2.哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliB站大学： 《重生之我在b站大学学逆向》，B站上有挺多的逆向师傅在上面分享解题过程什么     的，可以看看\n​    3.当然还有各位逆向大佬的博客，这边就不举栗子了（\n比赛类\nctftime：国际的高质量赛事\nctfhub：国内外赛事，可以订阅一下日历\n\n常用工具正所谓巧妇难为无米之炊，逆向没有工具的话，宛如夸父逐日\n反汇编工具IDA辣个女人必须得占据首位，这是现在已知最好用的反编译器了。正版比较贵就是了（，当然可以考虑去网上找找破解版，IDA配上插件再加上IDApython的脚本，那可真是顶中顶。\n大部分主流的架构都支持，可以用来调试linux的程序。\nGhidra江湖人称红龙，美国那边开发的，功能也挺强大，而且甚至开源，想深入了解反编译原理的可以去看看源代码（我是不敢看的\nOllyDbgwindows环境32位可执行文件唯一指定调试工具（大概，老传家宝了，在吾爱破解论坛那边找一个被那边大佬各种魔改，各种装插件，非常滴好用\nx64Dbgwindows环境64位可执行文件唯二指定调试工具，因为OD不支持x64 （：D\ndnspy.Net程序唯一指定分析工具，这位更是✌\ngdblinux环境下最常用的调试器，这位是pwn✌的最爱，想用也是可以用的\nJEB安卓反编译工具，反编译能力极强，还能代码追踪，添加备注什么的，缺点就是这个b代码结构有点烂，还有变量名跟ida有点像\nJadx-gui这位更是安卓反编译滴神，当然就是碰到比较大的apk时，容易崩溃罢了\n其他程序性质检查工具遇到题目，通常先要知道这是什么架构的，什么位数的，可能加过什么壳。\nDIE，PEiD就是这种Windows平台上的检查工具。\n我通常用的是DIE，能应付大多数要求，但是有些老的保护壳还是有可能查不出来。\n理论程序分析理论程序分析通常分为静态分析和动态分析。\n静态分析使用IDA等工具直接进行一个硬看代码，来观察其大致上的总体逻辑\n优势：静态分析能够快速探索多个分支（反正是肉眼看，想跳到哪里就跳到哪儿），获得大致的程序流程。\n劣势：没法获得CPU的实际内容，有可能存在误分析的情况；在被加壳，代码混淆，程序流混淆的情况下，静态分析会变得尤其困难。\n动态分析使用ollydbg等调试器，在调试状态下，对一个实际的程序路径进行分析。\n优势：能获得实际的CPU内容，便于了解真正的程序状态。动态分析可以获得内存中的实际内容，比静态分析中的静态字节码更有真实性：加壳程序，混淆程序的实际程序流程大都可以在调试的过程中摸清。动态调试脱壳也是一种常见手法。\n劣势：只能局限于一个程序执行流；遇到反调试，异常处理等手段下会比较难动态调试。\n实际分析中，都是动静态同时使用的。\n常见题型虚拟机虚拟机的简单理解，就是机器套机器，一种套娃行为。\n其本质就是实现一个作者自己实现的迫真指令集，然后基于这个指令集实现操作。\n虚拟机这个理念，最有名的实现，就是一个非常美丽（sb)的壳，叫做VMP。\n现代密码学加密入门时最容易遇到的加密题就是基于base64及其变体的题目。不过base64实际上不是加密，其实就是一个编码方式。\n正经比赛里的现代密码学加密题，包括但不局限于：TEA家族算法及其魔改，RC4流密码及其魔改，AES及其魔改，DES及其魔改\n偶尔还会出一些少见的密码，比如Chacha20，Salsa20，ECC非对称椭圆加密，甚至用gmp大数运算库实现RSA。非对称加密算法通常都是标准的，不会有什么魔改，也没有什么攻击要求，不像密码方向的题目。\nPythonPy脚本这个比较简单，入门时可能会遇到。可能会配合代码混淆\nPyc字节码Py脚本编译成Pyc字节码文件。最好了解一下Python栈虚拟机实现，以及Python的汇编语言。\n由Pyc字节码得到汇编，可以使用python自带的Pydisasm程序进行反汇编。\nGithub上面也有不少反编译工具（比如pycdc），能够直接将Pyc反编译成Py源代码。但是貌似没几个支持3.9及其以上的高版本的，所以学会读Python汇编还是一个很重要的技能。\n还有一件事（老爹音），要了解Pyc字节码文件的结构。\nPyd编译文件这位更是重量级中的重量级。Windows平台下用mingw编译出来的Pyd是最恶心的，没有调试信息。Linux平台下编译出so文件，至少还是有调试信息的。遇到这种题目，建议放到最后去看，因为大概率会看自闭。\nPyinstaller打包程序利用Pyinstaller打包后的exe程序。Github上面有几个解包工具，解包后，会得到一大坨的库文件，以及关键的程序文件。\n通常解包后会得到Pyc文件，但是是缺损头部信息的，需要使用配套的struct文件进行复原。（新版本的直接帮你补了，真好）\n具体不细说，反正就是要去了解Pyc字节码文件结构。\nGoGo语言也是一个非常美好（sb）的语言。IDA的反编译器生成的代码不精确，最多作为参考。\nRust这位更是跟上面一样的重量级。问题是近几年这类题出的好多，不得不学了（\n小游戏题大致上都是走迷宫什么的\n建议学习DFS，BFS或者A*走迷宫算法\n.Net用dnspy去分析.Net题。核心是C#。\nAndroid安卓apk逆向题。这是一个很大的方向，且一些混淆，加壳方法在apk上都能用。\nJava逆向jeb3逆向apk，审计java代码分析主体流程。\nfrida配环境是真麻烦啊（恼）。\n当然这种题型其实对于研究安卓方面的人是挺重要的，建议狠狠的学习。\n利用这个工具来获取apk中特定的内容。\nLinux基于Linux特性的一些题目。ptrace反调试，fork创造子进程等等。对Linux API要有一定的了解。\n代码混淆简单的比如有：变量名混淆，函数名混淆。这都是在有调试信息的情况下搞的。\nRe中比较常见的是真正的对程序执行流进行调整，变形而实现的混淆。\n基础的有花指令，SMC这类，前者是塞进去一点垃圾代码，来让程序不是很好地进行反编译，后者则是直接把整个函数给他加密了\n稍微进阶一点的比如ollvm，虚假控制流等。这些混淆在GitHub上面都有复原工具。\n总结逆向工程这个东西讲究的就是多调，多看，多分析，最好也是自己写一点加壳什么的或者混淆，这样慢慢学起来应该没问题\n","categories":["study"],"tags":["teaching"]},{"title":"CISCN2024部分复现","url":"/2024/07/16/CISCN2024Re%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/","content":"CISCN2024部分Re题复现非常好国赛，使我的逆向旋转，frida,go,rust和cython什么玩意儿都来了，头都要大了\nasm_re上来一个汇编语言，看着就像是从IDA里面直接拖过来的东西\n\n首先是看着像初始化的东西，可以不用管\n\n这里可以看出是加密方法，学点汇编就大概知道是个什么意思了\n\n这边是密文，简单写个脚本解密即可（虽然比赛过程中处处犯傻\nenc = [0x1fd7, 0x21b7, 0x1e47, 0x2027, 0x26e7, 0x10d7, 0x1127, 0x2007, 0x11c7, 0x1e47, 0x1017, 0x1017, 0x11f7, 0x2007,       0x1037, 0x1107, 0x1f17, 0x10d7, 0x1017, 0x1017, 0x1f67, 0x1017, 0x11c7, 0x11c7, 0x1017, 0x1fd7, 0x1f17, 0x1107,       0xf47, 0x1127, 0x1037, 0x1e47, 0x1037, 0x1fd7, 0x1107, 0x1fd7, 0x1107, 0x2787] //密文注意小端序问题flag = &#x27;&#x27;for i in enc:    i = (((i -0x1e) ^ 0x4d) - 0x14) // 0x50    flag += chr(i)print(flag)\n\nandroid_re我勒个frida啊，配环境是一辈子的，frida是不会用的，现在只能开始恶补了（\n\n这个是主函数，可以看到引用了inspect\n\n来到inspect,可以看到是DES加密，需要Key和iv,\n\n可以看到是有个lib被调用了，去找找看\n\n\n上面是getiv,下面是getkey，可以看得出来这个静态分析的难度那是相当滴大（是这样的，我看了一小时看不出来半点，所以应该采用动调的方式，因为这个是so文件，只是个库，无法主动执行，所以需要用到动调（噩梦来了）\n我这边利用的是unidbg，这边可供选择也挺多的，还有可爱（sb）的frida以及objection\n他们都有一个共同的特点，环境难配\npackage com.ciscn; import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;// 导入通用且标准的类库import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;  import java.io.*; public class ciscna extends AbstractJni &#123;    private final AndroidEmulator emulator; //android 模拟器 a    private final VM vm;//vm 虚拟机    private final Module module;    private final Memory memory;    private final DalvikModule dm;     //将该类封装起来，以后直接套用模板    public ciscna(String apkFilePath, String soFilePath, String apkProcessname) throws IOException &#123;        // 创建模拟器实例,进程名建议依照实际进程名填写，可以规避针对进程名的校验        emulator = AndroidEmulatorBuilder.for64Bit().setProcessName(apkProcessname).build();        memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(apkFilePath));        vm.setVerbose(false); // 打印日志，会在调用初始化 JNI_unload 打印一些信息，默认：false        // 加载目标 SO        dm = vm.loadLibrary(new File(soFilePath), true); // 加载 so 到虚拟内存，第二个参数：是否需要初始化        //获取本 SO 模块的句柄        module = dm.getModule();        vm.setJni(this); //设置 Jni，防止报错        //创建完后，需要调用 JNI_onload 函数        dm.callJNI_OnLoad(emulator); // 调用 JNI OnLoad，进行动态注册某些函数。如果都是静态注册，那就不用调用这个函数        vm.setVerbose(true);        // Debugger debugger = emulator.attach();        // debugger.addBreakPoint(module.base + 0x1924C);        // debugger.addBreakPoint(module.base + 0x19240);    &#125;     public ciscna(AndroidEmulator emulator, VM vm, Module module, Memory memory, DalvikModule dm) &#123;        this.emulator = emulator;        this.vm = vm;        this.module = module;        this.memory = memory;        this.dm = dm;    &#125;     public String func_getKey() &#123;        DvmClass dvmClass = vm.resolveClass(&quot;com.example.re11113.jni&quot;);        DvmObject&lt;?&gt; object = dvmClass.newObject(null);        DvmObject&lt;?&gt; object1 = object.callJniMethodObject(emulator, &quot;getkey()Ljava/lang/String;&quot;);        return object1.getValue().toString();    &#125;     public String func_getiv() &#123;        DvmClass dvmClass = vm.resolveClass(&quot;com.example.re11113.jni&quot;);        DvmObject&lt;?&gt; object = dvmClass.newObject(null);        DvmObject&lt;?&gt; object1 = object.callJniMethodObject(emulator, &quot;getiv()Ljava/lang/String;&quot;);        return object1.getValue().toString();    &#125;     //创建一个 main 函数    public static void main(String[] args) throws IOException &#123;        // 1、需要调用的 so 文件所在路径        String soFilePath = &quot;/root/Documents/unidbg/unidbg-android/src/test/java/com/ciscn/libSecret_entrance.so&quot;;         // 2、APK 的路径        String apkFilePath = &quot;/root/Documents/unidbg/unidbg-android/src/test/java/com/ciscn/app-debug.apk&quot;;        // 3、apk 进程名        String apkProcessname = &quot;com.tencent.testvuln&quot;;        ciscna myapp = new ciscna(apkFilePath, soFilePath, apkProcessname);        System.out.println(&quot;getKey result:&quot; + myapp.func_getKey());        System.out.println(&quot;getiv result:&quot; + myapp.func_getiv());    &#125;&#125;\n\n看得很复杂对吧，实际上就一个模板，改改参数就行了（对我这个安卓动调苦手太好了\n\n跑出来结果\n可以看到key和iv的值都被我们成功的hook出来了\n\n用flag{}包起来即可\n当时表示用frida狠狠的报错（心态是逐渐崩溃\nGoReverse嘻嘻，加密东西写满了我整个小白板了，你个b东西\n首先打开main_main函数\n\n上面部分经过分析是反调试的东西，我谢谢你\n接下来来到main__ptr_co6Pxq_Execute函数\n\n查看汇编发现就是一臭打招呼的，可以继续往下走了\n然后来到重量级的main__ptr_B2bUPq_Execute\n\n首先这部分代码是判断是否读取到了flag文件\n\n中间这部分是加密（suprise\n下面就是判断了\n可以看得出来重要的都是一个个main为前缀的函数，一个个来吧\nmain_ylFyZv\n首先是一大堆的代码，不过前面几行不要管，重要的是下面的for循环，可以看到是最友好的异或\n\n这个就是我们拿来异或的密钥了\nmain_bytesToUint32s这个是修改类型的，可以不用管\nmain_zQyveE\n可以看出很明显的xxtea算法，delta值是改过的，main_KjmS3y函数就是MX,但是顺序变了\nmain_Q05qm6\n看到那个littleEndian了吗，这个就是这个函数的作用了\nmain_AkuFrt\n最逆天的来了\n可以看到这里用了随机数和sm4\n看看汇编\n\n可以看到了用了CTR的方法，key值我们是有了，但是iv我们却没有\n那么我们的iv哪来呢，用了非常好的随机数，所以说我们需要动调（乐\n首先这个程序有两处反调试，第一个我们在main_main函数的时候已经说过了\n另一段在0x0438E28，也就是在调用main_main函数的runtime_main函数中，动调的时候发现执行这个call之后程序就退出了，nop掉之后程序正常运行。\n\n随后就可以进行动调了\n\nmain_JrkmHd\n这个函数则是AES加密，然后经典key值一查就有，iv一查一个不知道\n要注意的是有个makeslice函数，这个是go语言里面的切片函数，实际作用就是把你key里面的前16位拿过来然后变成了iv（乐\nmain_NJVCTq\n最后一个base32就好了。\n总体来说就是非常的套娃，头大，那么问题来了，密文呢\n看看我们的最初的函数，可以看到我们需要有个flag文件，这里是复现，所以我们自己弄一个，然后远程连接一下\n\n这不就来了吗，解密过程就不给了，也是个麻烦仙人（\nwhereThel1b人生第二次碰到的cython，给了个py文件和so库，看看py\nimport whereThel1bflag = input(&quot;where is my flag:&quot;)flag = flag.encode()encry = [108, 117, 72, 80, 64, 49, 99, 19, 69, 115, 94, 93, 94, 115, 71, 95, 84, 89, 56, 101, 70, 2, 84, 75, 127, 68, 103, 85, 105, 113, 80, 103, 95, 67, 81, 7, 113, 70, 47, 73, 92, 124, 93, 120, 104, 108, 106, 17, 80, 102, 101, 75, 93, 68, 121, 26]whereThel1b.whereistheflag(flag)ret = whereThel1b.trytry(flag)if ret == encry:    print(&quot;rrrrrrrrrrrright&quot;)else:    print(&quot;wwwwwwwwwwwwwwwrong&quot;)\n\n可以发现是调用了这个库，于是得对这个文件进行一个快乐的审计\n\n首先是whereistheflag，可以发现有base64加密，然后再往下看\n\n发现有个random库，还有randint方法，按理说应该都会有个seed的，往下翻就没有什么其他有用的东西了，去trytry函数\n\n可以看到有random.seed这个方法，那么问题来了，中间的值呢,比赛期间找到似都找不到\n其实挺简单的，首先可以确定的是cython中的常量（即数字）会是__pyx_int_x，其中x是数字，所以seed是\n\n另外的话如果是利用变量这种东西，会以__pyx_n_s_a这种形式出现，其中a就是我们的变量，字符串这种则是__pyx_kp_s_Hello_cython这种形式，Hello_cython就是我们的字符串，所以我们就可以按照这样的格式来确定。\nexp:\nimport randomimport base64encry = [108, 117, 72, 80, 64, 49, 99, 19, 69, 115, 94, 93, 94, 115, 71, 95, 84, 89, 56, 101, 70, 2, 84, 75, 127, 68, 103, 85, 105, 113, 80, 103, 95, 67, 81, 7, 113, 70, 47, 73, 92, 124, 93, 120, 104, 108, 106, 17, 80, 102, 101, 75, 93, 68, 121, 26]random.seed(0)for i in range(len(encry)):    encry[i] = encry[i] ^ random.randint(0, len(encry))flag = base64.b64decode(bytes(encry))print(flag)\n\n","categories":["study"],"tags":["复现"]}]