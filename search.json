[{"title":"逆向入门","url":"/2024/07/07/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8/","content":"逆向简单入个门简单讲两句逆向工程入门这个东西（有什么讲不好的地方轻点喷）\n什么是逆向工程什么是逆向？ 通俗来讲就是，计算机科学中的逆向工程就是将机器才能够懂的机器代码（二进制代码）翻译成人能够读懂的代码（汇编代码，C语言代码），并在此基础上分析出程序的工作流程。\n举个栗子写一个简单的C语言程序\n#include &quot;windows.h&quot;#include &quot;tchar.h&quot;int _tmain(int argc, TCHAR* argv[])&#123;\tMessageBox(\t\tNULL,\t\tL&quot;Hello World&quot;,\t\tL&quot;just a reverse&quot;,\t\tMB_OK\t);\treturn 0;&#125;\n\n用gcc或者其他编译器或者IDE进行编译\ngcc helloworld.c -o helloworld.exe\n\ngcc这个编译器实际上是linux那边的开源编译器，然后的话我这边是用vs编译的（偷个懒\n这边把生成的程序根据对应的架构，放入到对应的调试器里面，我这边生成的是32位的，所以丢到ollydbg里面（简称OD）,64位的要丢到x64dbg里面\n前面OD反汇编了不少启动函数，这边先啥也不管，直接来到我们的主函数main()这边\n\n这个就是我们编译出来的代码的汇编语言\n虽然现在有ghira，ida这种高级反汇编工具能生成跟源代码相近的c语言伪代码，但是作为逆向工程的基础，汇编语言还是很重要的，所以还是得去阅读，尝试去分析和理解这种格式的汇编代码\n前置条件入门需要的科技树：\n​        1.C语言的代码审计能力（这个东西入门时期最重要的）\n​        2.汇编语言：通常是x86-64架构指令\n​        3.调试能力\nCTF-Re快速入门问就是刷题，狠狠的刷题，在各种的刷题平台上狠狠的刷题\n常见的平台有:BUUCTF在线评测 (buuoj.cn),攻防世界 (xctf.org.cn),nssctf（https://www.nssctf.cn/index）\n入门期间，如果可以的话，最好是每天一题的频率，每天在刷题的时候，也最好学习一些相应的知识\n要是碰到实在做不出来的，完全可以是去查找对应的writeup（简称wp）,俗称就是看前人的写题过程，当然最好是找那些详细的，有些人写wp很简略的。\n在刷到一定程度之后，可以适当的去打打一些线上的新生赛这种，在不会太难的程度上，同时学习一些新东西。\n推荐书籍这种东西其实入门的时候不怎么需要，当然日后要是深入的话，书籍可太需要了\n我这边就讲讲我个人比较喜欢的书\n1.逆向工程核心原理：这本书是windows环境下的逆向书籍，里面内容挺详细的\n2.C++反汇编与逆向分析技术揭秘：非常好的小黄书，使我的逆向旋转，挺经典的一本，可以看看\n3.C Primer Plus: 学C语言用的，但是找一些比较偏的语法是找不到的\n4.汇编语言 基于x86处理器：挺详细一本汇编语言书，我学汇编就看的这本\n5.深入理解计算机系统：四舍五入这也是本前置条件，是我想买但没买的书（\n6.Linux二进制分析：linux环境的话可以看看这本\n7.程序员的自我修养——链接、装载与库：介绍了 C 源代码如何经过一系列的操作最终变为二进制程序\n8.加密与解密：看雪论坛最新力作（就是有点贵），里面讲的挺多关于逆向保护和破解方面的东西\n9.IDA权威指南：这位更是IDA作者鼎力推荐，教会你如何快乐地使用IDA\n推荐资源教程类​    1.简介 - CTF Wiki (ctf-wiki.org) : wiki里面有比较详细的解读\n​    2.哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliB站大学： 《重生之我在b站大学学逆向》，B站上有挺多的逆向师傅在上面分享解题过程什么     的，可以看看\n​    3.当然还有各位逆向大佬的博客，这边就不举栗子了（\n比赛类\nctftime：国际的高质量赛事\nctfhub：国内外赛事，可以订阅一下日历\n\n常用工具正所谓巧妇难为无米之炊，逆向没有工具的话，宛如夸父逐日\n反汇编工具IDA辣个女人必须得占据首位，这是现在已知最好用的反编译器了。正版比较贵就是了（，当然可以考虑去网上找找破解版，IDA配上插件再加上IDApython的脚本，那可真是顶中顶。\n大部分主流的架构都支持，可以用来调试linux的程序。\nGhidra江湖人称红龙，美国那边开发的，功能也挺强大，而且甚至开源，想深入了解反编译原理的可以去看看源代码（我是不敢看的\nOllyDbgwindows环境32位可执行文件唯一指定调试工具（大概，老传家宝了，在吾爱破解论坛那边找一个被那边大佬各种魔改，各种装插件，非常滴好用\nx64Dbgwindows环境64位可执行文件唯二指定调试工具，因为OD不支持x64 （：D\ndnspy.Net程序唯一指定分析工具，这位更是✌\ngdblinux环境下最常用的调试器，这位是pwn✌的最爱，想用也是可以用的\nJEB安卓反编译工具，反编译能力极强，还能代码追踪，添加备注什么的，缺点就是这个b代码结构有点烂，还有变量名跟ida有点像\nJadx-gui这位更是安卓反编译滴神，当然就是碰到比较大的apk时，容易崩溃罢了\n其他程序性质检查工具遇到题目，通常先要知道这是什么架构的，什么位数的，可能加过什么壳。\nDIE，PEiD就是这种Windows平台上的检查工具。\n我通常用的是DIE，能应付大多数要求，但是有些老的保护壳还是有可能查不出来。\n理论程序分析理论程序分析通常分为静态分析和动态分析。\n静态分析使用IDA等工具直接进行一个硬看代码，来观察其大致上的总体逻辑\n优势：静态分析能够快速探索多个分支（反正是肉眼看，想跳到哪里就跳到哪儿），获得大致的程序流程。\n劣势：没法获得CPU的实际内容，有可能存在误分析的情况；在被加壳，代码混淆，程序流混淆的情况下，静态分析会变得尤其困难。\n动态分析使用ollydbg等调试器，在调试状态下，对一个实际的程序路径进行分析。\n优势：能获得实际的CPU内容，便于了解真正的程序状态。动态分析可以获得内存中的实际内容，比静态分析中的静态字节码更有真实性：加壳程序，混淆程序的实际程序流程大都可以在调试的过程中摸清。动态调试脱壳也是一种常见手法。\n劣势：只能局限于一个程序执行流；遇到反调试，异常处理等手段下会比较难动态调试。\n实际分析中，都是动静态同时使用的。\n常见题型虚拟机虚拟机的简单理解，就是机器套机器，一种套娃行为。\n其本质就是实现一个作者自己实现的迫真指令集，然后基于这个指令集实现操作。\n虚拟机这个理念，最有名的实现，就是一个非常美丽（sb)的壳，叫做VMP。\n现代密码学加密入门时最容易遇到的加密题就是基于base64及其变体的题目。不过base64实际上不是加密，其实就是一个编码方式。\n正经比赛里的现代密码学加密题，包括但不局限于：TEA家族算法及其魔改，RC4流密码及其魔改，AES及其魔改，DES及其魔改\n偶尔还会出一些少见的密码，比如Chacha20，Salsa20，ECC非对称椭圆加密，甚至用gmp大数运算库实现RSA。非对称加密算法通常都是标准的，不会有什么魔改，也没有什么攻击要求，不像密码方向的题目。\nPythonPy脚本这个比较简单，入门时可能会遇到。可能会配合代码混淆\nPyc字节码Py脚本编译成Pyc字节码文件。最好了解一下Python栈虚拟机实现，以及Python的汇编语言。\n由Pyc字节码得到汇编，可以使用python自带的Pydisasm程序进行反汇编。\nGithub上面也有不少反编译工具（比如pycdc），能够直接将Pyc反编译成Py源代码。但是貌似没几个支持3.9及其以上的高版本的，所以学会读Python汇编还是一个很重要的技能。\n还有一件事（老爹音），要了解Pyc字节码文件的结构。\nPyd编译文件这位更是重量级中的重量级。Windows平台下用mingw编译出来的Pyd是最恶心的，没有调试信息。Linux平台下编译出so文件，至少还是有调试信息的。遇到这种题目，建议放到最后去看，因为大概率会看自闭。\nPyinstaller打包程序利用Pyinstaller打包后的exe程序。Github上面有几个解包工具，解包后，会得到一大坨的库文件，以及关键的程序文件。\n通常解包后会得到Pyc文件，但是是缺损头部信息的，需要使用配套的struct文件进行复原。（新版本的直接帮你补了，真好）\n具体不细说，反正就是要去了解Pyc字节码文件结构。\nGoGo语言也是一个非常美好（sb）的语言。IDA的反编译器生成的代码不精确，最多作为参考。\nRust这位更是跟上面一样的重量级。问题是近几年这类题出的好多，不得不学了（\n小游戏题大致上都是走迷宫什么的\n建议学习DFS，BFS或者A*走迷宫算法\n.Net用dnspy去分析.Net题。核心是C#。\nAndroid安卓apk逆向题。这是一个很大的方向，且一些混淆，加壳方法在apk上都能用。\nJava逆向jeb3逆向apk，审计java代码分析主体流程。\nfrida配环境是真麻烦啊（恼）。\n当然这种题型其实对于研究安卓方面的人是挺重要的，建议狠狠的学习。\n利用这个工具来获取apk中特定的内容。\nLinux基于Linux特性的一些题目。ptrace反调试，fork创造子进程等等。对Linux API要有一定的了解。\n代码混淆简单的比如有：变量名混淆，函数名混淆。这都是在有调试信息的情况下搞的。\nRe中比较常见的是真正的对程序执行流进行调整，变形而实现的混淆。\n基础的有花指令，SMC这类，前者是塞进去一点垃圾代码，来让程序不是很好地进行反编译，后者则是直接把整个函数给他加密了\n稍微进阶一点的比如ollvm，虚假控制流等。这些混淆在GitHub上面都有复原工具。\n总结逆向工程这个东西讲究的就是多调，多看，多分析，最好也是自己写一点加壳什么的或者混淆，这样慢慢学起来应该没问题\n","categories":["study"],"tags":["teaching"]}]